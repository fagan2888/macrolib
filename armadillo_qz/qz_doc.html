<a name="qz"></a>
<b>qz( mat AA, mat BB, mat Q, mat Z, mat A, mat B )</b>
<br>
<br><b>qz( cx_mat AA, cx_mat BB, cx_mat Q, cx_mat Z, cx_mat A, cx_mat B )</b>
<ul>
<li>
Generalized Schur decomposition for pair of general <b>dense</b> square matrices <i>A</i> and <i>B</i> of the same size,
such that <i>A &nbsp;=&nbsp; Q.t()*AA*Z.t()</i>, <i>B &nbsp;=&nbsp; Q.t()*BB*Z.t()</i>
</li>
<br>
<li>The left and right Schur vectors are stored in <i>Q</i> and <i>Z</i>, respectively</li>
<br>
<li>In the complex-valued problem, the generalized eigenvalues and corresponding eigenvectors are found in <i>diag(AA) / diag(BB)</i></li>
<br>
<li>If <i>A</i> or <i>B</i> is not square, a <i>std::logic_error</i> exception is thrown</li>
<br>
<li>If the decomposition fails:
<ul>
<li><i>qz(AA, BB, Q, Z, A, B)</i> resets <i>AA</i>, <i>BB</i>, <i>Q</i>, and <i>Z</i>, and returns a bool set to <i>false</i> (exception is not thrown)</li>
</ul>
</li>
<br>
<li>
Examples:
<ul>
<pre>
mat A = randu&lt;mat&gt;(10,10);
mat B = randu&lt;mat&gt;(10,10);

mat Q; mat Z; mat AA; mat BB;
qz(AA, BB, Q, Z, A, B);


cx_mat C = randu&lt;cx_mat&gt;(10,10);
cx_mat D = randu&lt;cx_mat&gt;(10,10);

cx_mat Qc; cx_mat Zc; cx_mat AAc; cx_mat BBc;
qz(AAc, BBc, Qc, Zc, C, D);
</pre>
</ul>
</li>
<br>
<li>
See also:
<ul>
<li><a href="#eig_pair">eig_pair()</a></li>
<li><a href="https://en.wikipedia.org/wiki/Schur_decomposition#Generalized_Schur_decomposition">generalized Schur decomposition in Wikipedia</a></li>
</ul>
</li>
<br>
</ul>
<hr class="greyline"><br>